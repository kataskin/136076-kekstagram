# Защита
Очень зрелый, грамотный и умный код! Приятно читать. Особенно приятно видеть что за кодом есть мысль, что это не копипаст, а настоящий продукт. Респектую:)

Несколько замечаний все-таки есть, но они легкие и исправляются на раз.

## Б1. Код соответствует техническому заданию проекта
### Таймаут (задание #11 «Шаблонизируй это»)
В файле `generator.js` не хватает обработчика таймера, но это вопрос и ко мне, потому что оказывается в задании про него ничего не сказано:) Если будет — хорошо.

### Один объект запроса (задание #12 «Робкое знакомство с AJAX»)
В файле `loader.js` используется один объект XHR для всех запросов. Пока нет параллельных запросов, такой код будет работать, но это неправильное решение. Если делать два асинхронных запроса непосредственно один за другим с помощью одного объекта XHR, то, если первый запрос не успеет отправиться или вернуться, он будет отменен и вместо него будет отправлен второй. Я бы переделал вот как: в функции `load`, создавал бы новый `xhr`, все обработчики добавлял бы в нем, а функцию, которая прописана в `onload` сохранил бы в единственном числе с названием, чтобы убирать подписку на нее (см. коммент ниже про удаление подписки на `onload` у картинок. Здесь неплохо бы провернуть подобную схему).

### Не сохраняется номер открытой в галерее фотки в адрес страницы (задание #20 «Запомнить всё»)
Задание на самом деле проще чем кажется: достаточно в файле `gallery.js` привязать метод `showPicture` не к клику по объектам а к изменению хэша. То есть методы `showIndex/showNextPicture/showPrevPicture` должны не вызывать `showPicture`, а просто изменять хэш страницы через `location.hash`, а в конструкторе галереи должен быть обработчик события `onhashchange` на объекте `window`, который бы всё это дело перехватывал и вызывал показ нужной фоточки (`showPicture`)

## Б3. Минимизированы потенциальные утечки памяти
### Недобитые обработчики
В `generator.js` можно улучшить работу с обработчиками для картинок:
во-первых, сейчас для каждой новой картинки создаются по две новых функции-обработчика, потому что используются анонимные функции:
```javascript
image.onload = function() {};
```
Если придумать название функциям и записать их в отдельные переменные, можно будет присваивать в качестве обработчиков уже существующие функции:
```javascript
var onImageLoad = function() {};

var create = function() {
  image.onload = onImageLoad;
}
```
В этом случае в памяти будет храниться не по две одинаковых функции для каждой картинки, а просто ровно две функции. Кроме этого, обработчики неплохо бы удалять. Если картинка загрузилась успешно, у нее продложают висеть в памяти обработчики ошибки и успеха загрузки, хотя сама картинка повторно загружаться уже не будет, поэтому по выполнению любого обработчика, можно убрать у картинки как `onload` так и `onerror` (если использовать такой стиль, то приравнять к `null`, или переписать на `addEventListener/removeEventListener`)

### Многовато биндов в `gallery.js`
В методе `show` у `Gallery` каждый раз перезаписывается метод `hideGalleryByClick`, перебиндиваясь на контекст `this`. Фактически происходит вот что. Он берет существующий метод и добавляет ему контекст, потом, при следующем показе, берет метод с уже привязанным контекстом и перепривязывает его заново. Каждый раз фактически создается новая функция и бог его знает, как это происходит в кишках у браузера, может быть он помнит все ссылки, надо же ему откуда-то брать изначальную функцию. То есть через 10 показов, метод `hideGalleryByClick` будет выглядеть примерно вот так:
```javascript
function() {
  function() {
    function() {
      function() {
        function() {
          function() {
            hideGalleryByClick.call(this);
          }.call(this);
        }.call(this);
      }.call(this);
    }.call(this);
  }.call(this);
}
```
Я бы сохранил для этой функции контекст один раз — в конструкторе:)

## Б5. Код оформлен единообразно и соответствует гайдлану
### Разные обработчики в load
То `addEventListener`, то `onload`. В случае с XHR сложно отдать предпочтение какому-то способу, `addEventListener` однозначно необходим только для DOM-элементов, поэтому можно выбрать любой, какой нравится

## Б9. Код разделен на модули
### Налицо небольшая переоптимизация, можно проще
- не совсем понял, зачем нужен модуль `pictures`
- не совсем понял, зачем нужен модуль `container`

Точнее понятно, зачем они нужны, просто я бы пошел по другой стратегии — я бы активней использовал файл `main`. Обычно входная точка как раз и используется для начинания всех активностей. У вас сделано так, что триггером ко всему является `pictures`, а `container` нужен два раза, потому что используется в двух местах. Я бы обе эти проблемы решал более активным перенесением логики в `main`

В целом, это необязательно, просто в таком виде достаточно сложно будет прочитать код через какое-то время, но если вас устраивает можно оставить как есть

### Можно оптимизировать экспорты
Простое правило: если в `module.exports` записывается объект с одним свойством, от этого объекта можно смело избавиться. **Было:**
```javascript
module.exports = {
  load: function() {

  }
}
```
**Стало:**
```javascript
module.exports = function() {

}
```
Заодно использовать код будет проще — всегда хорошо когда меньше букав:)

### Сложноватая структура галереи
`showNextPicture` и `showPrevPicture` очень похожи, у них практически одинаковый код с разницей только в том как они проверяют границу. Может быть имеет смысл избавиться от этих методов совсем и добавить вызов вида `this.show(this.currentPictureIndex++) // или --`, а в методе `show` проверять на выход из обеих границ и нормализовать значение, если оно передано неправильно

---

## Д3. Небольшая цикломатическая сложность функций
Напишу в этом критерии, потому что это замечание более-менее подходит под него. Проверка на существование `localStorage` кажется сложноватой, можно просто проверить, существует ли объект `localStorage` в глобальной области видимости. Например:
```javascript
var isLocalStorageSupported = function() {
  return 'localStorage' in window;
};
```

## Д7. Выполнено совсем дополнительное задание к заданию #6 «Canvas» из раздела «Графика»
Не выполнено:)

## Д8. Выполнено дополнительное задание к заданию #9 «Валидация» из раздела «Знакомство с DOM»
Nope.

## Д9. Выполнена первая часть дополнительного задания к заданию #21 «Контексты и прототипы» из раздела ## «Состояния и синхронизация»
Не-а.

## Д10. Выполнена вторая часть дополнительного задания к заданию #21 «Контексты и прототипы» из раздела ## «Состояния и синхронизация»
Не було.

## Д11. Выполнена первая часть второго дополнительного задания к заданию #21 «Контексты и прототипы» из ## раздела «Состояния и синхронизация»
Нэ здэлана!

## Д12. Выполнена вторая часть второго дополнительного задания к заданию #21 «Контексты и прототипы» из ## раздела «Состояния и синхронизация»
Ни знайшов:/
